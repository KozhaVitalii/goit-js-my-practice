/*
 * Классы
 * 🐷 - объявление
 * 🐷 - конструктор
 * 🐷 - методы
 * 🐷 - static
 * 🐷 - приватные свойства
 * 🐷 - синтаксис публичных свойства и методы классов
 * 🐷 - геттеры и сеттеры
 */

// Класс - это новый способ записывать функцию конструктор с уже готовым прототипом (т.е. со свойством prototype).
// На практике чаще прийдется юзать классы чем функции конструктор.

// Для объявления класса используется ключевое слово "class"

// Полная запись: ключевое слово class имя и {}. Пример:
// class Car { };
// После чего просто вызываем класс в экземпляре:
// const car carInstance = new Car();
// console.log(carInstance);

// Применяется все та же логика, что и с использованием функции конструктора.

// Далее методы класса мы описываем следующим синтаксисом:

class Car { 
    constructor() { }  // сразу после инициализации (создании) экземпляра const car carInstance = new Car(); выполниться метод constructor() { } автоматически.

};

// "function (config = {}) {
// this.brand = brand;
// this._model = model;
// this._price = price;
// }" - вот эта часть и метод  constructor() { } это одно и тоже. Полная запись с использованием сonstructor() {}
// будет выглядеть так:
//     constructor({ brand, model, price } = {}) {
//         this.brand = brand;
//         this._model = model;
//         this._price = price;
//     }

//      changePrice (newPrice) {
//          this.price = newPrice;
//   }
//      updateModel(newModel) {
//          this.model = model;
// }
// }

// В примере выше следует обратить внимание на синтакиси, методы описанные внутри класса не разделяются ни ","
// ни ";" объявление нового метода без this и "= function"

// Все что идёт на экземпляр живет и описано в constructor() { }, все что идёт на прототип описывается ниже,
// это всякие методы и свойства.

// Обычно структура класса такая:
// 1. объявляются все статические свойства и методы (которые обычно используются для хранения констант,
// методов которые не идут на экземпляр, типа: обджек.велью, обджек, ки, гетпрототайпов и т.д., которые на
// функции вызываются)
// 2. конструктор(в котором описываются свойства для экземпляров)
// 3. все методы которые могут вызываться и использоваться экземплярами

// Приватное свойство записывается с таким синтаксисом: #test ну или более полная запись #test = 'test';
// т.е. перед свойством указываем "#". При этом приватные свойства могут быть только у самого класса,
// если объявить свойство в конструкторе, вот так: this.#test = 'test'; т.е.написать свойство которое будет
// доступно экземплярам, будет ошибка в коде. При этом приватные свойста мы можем использовать (а именно
// получить значение в методах прописанных в классах, которые в свою очередь используются в экземплярах.


// Синтаксис публичного свойства:

// myPablicField = 777; - просто объявляется внутри класса после статических свойст и до конструктора(но не
// внутри конструктора.) Хотя такая запись myPablicField = 777; будет равна свойству объявленному внутри
// конструктора this.myPablicField = 777; А точнее таоке объявление myPablicField = 777 далее приобразуется
// в this.myPablicField = 777;
// Все что мы объявляем публичным свойством будет доступно в свойствах прототипа.

// Разберем концепцию геттеров и сеттеров:
// Допустим мы хотим добавить два метода в класс(или конструктор функции), которые будут получать значения
// свойства либо добавлять новое значение свойству:

// setModel(){
//     this.model
// };

// getModel(){
//     this.model
// };

// Такая запись методов не оптимальная т.к. в результате в коде будет куча вызовов методов getModel и setModel

// Вместо этого используют геттеры и сеттеры.Что они делают ? Они заменяют обращение и запись какого - то
// свойства, т.е.вместо описанных выше двух методов, мы можем сделать сеттер и геттер для доступа к свойству
// model(как в примере). Как єто работает?

// Для начала сделаем геттер:

// get model() { }  // указываем спец конструкцию get далее пробел и свойство для которого прописывам гетер
// функцию.Что будет делать такая функция ?
// Правило : геттеры и сетеры не могут использовать тоже название свойства которое они описывают(с которыми
// они работают). Так будет выглядеть функция геттер:

// get model() {
//     return this._model
// }
// "_model" - так должно называться внутреннее свойство класса (такой признак внутреннего свойства)

// Далее если мы вызовем console.log(carInstance.model) мы получим значение свойства модель

// Для сетера будет такая же запись и при вызове функции мы будем набирать так carInstance.model:
// set model() {
//     return this._model
// }

// Но когда мы хотим получить значение свойства мы будем указывать к примеру console.log(carInstance.model),
// в этом случае вызовется геттер, а когда мы хотим записать новое значение в это свойство
// carInstance.model = Q4, при такой записи вызовется сеттер

// В итоге если раньше мы вызывали методы, то теперь мы как будто обращаемся к свойству, т.е. интерфейс упростился.


class Car {
    static description = 'Класс описывающий автомобиль'; // так записывается статическое свойство 
    // перед constructor() { }, после статического свойства обязательно указывается ";"

    static logInfo(carObj) {
        console.log('Car.logInfo -> carObj', carObj);
    }

    constructor({ brand, model, price } = {}) {
        this.brand = brand;
        this._model = model;
        this._price = price;
    }

    get price() {
        return this._price;
    }

    set price(newPrice) {
        this._price = newPrice;
    }

    get model() {
        return this._model;
    }

    set model(newModel) {
        this._model = newModel;
    }
}

const carInstance = new Car({
    brand: 'Audi',
    model: 'Q3',
    price: 35000,
});

console.log(carInstance.model);
carInstance.model = 'Q4';
console.log(carInstance.model);

console.log(carInstance.price);
carInstance.price = 50000;
console.log(carInstance.price);

console.log(carInstance);
