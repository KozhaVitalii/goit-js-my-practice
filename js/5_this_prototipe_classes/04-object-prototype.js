/*
 * Прототип объекта
 *
 * - https://miro.com/app/board/o9J_ku0WE0g=/
 * - Object.create()
 * - [[Prototype]] и __proto__
 * - Object.getPrototypeOf()
 * - Собственные свойства и Object.prototype.hasOwnProperty()
 * - Цепочка прототипов
 */

// Прототипное наследование это буквально возможность связать объекты по ссылке.В результате получается некая
// цепока объектов с которыми работает механизм и ищет для объекта свойства которых нет на самом объекте.
// Прототип это резервное хранилище для свойств и методов объектов и если объекты связать с этим хранилищем, то
// можно будет из одного объекта получать свойтва других объектов подключенных к этому хранилищу.

// У каждого бъекта есть свойство __proto__ в этом свойстве лежит ссылка на прототип этого же либо другого объекта
// с какими то свойствами и методами.

// Ссылки объекта на другие объекты мы можем настраивать вручную.К примеру создали объект objA и хотим чтобы
// прототипом для него был объект objB. Другими словами нам необходимо чтобы в свойство __proto__ объекта objA
// записалась ссылка на объект objB(о всеми его свойствами).После такой связи objB становится прототипом для
// objA.
// Мы можем настраивать целые цепочки связей для разных объектов.
// objA(имеет свойство А) > objB(имеет свойство В) < objB(имеет свойство С) - в такой связке для объекта А
// прототипом будет выступать объект В, а для объекта В прототипом будет объект С, при этом из объекта А
// мы можем получить ссылку на свойства объекта С.

// Важно понимать что у одного объекта может быть ссылка только на один(не более) другой объект, т.е.связь
// может быть только 1:1. Такие объекты можно связать в цепочку в конце которой будет главный объект
// на который в итоге через связи будут ссылать все объекты цепочки.У такого главного объекта будет главное
// свойство Object.prototype

// Цепочку необходимо выстраивать с конца. Т.е. сначала создаем главный объект, к примеру С.
// При выстраивании цепочки создаются ссылки а не копии объектов.

// const objC = {
//   z: 5,
// };

// const objB = Object.create(objC); // таким образом мы создаем пустой объект и привязываем прототип (С) к новому объекту (В)
// objB.y = 2;

// const objA = Object.create(objB);
// objA.x = 1;

// console.log(objA.z); // в итоге через объкт А мы можем достучаться до свойств объекта С и В.

// Если мы создадим на объекте А тоже свойство что и на объекте С и запишем в него новое значение, на объекте
// С сохраниться его исходное значение а на объекте А появится новое.А
// К примеру у объекта С есть свойство z: 5, мы к нему можем достучаться через цепочку связей которую описали
// выше.Но если мы на объекте А переопределим значение для свойсва "z", к примеру установим z: 10, то в
// результате на объекте А будет свойство с новым значением z: 10, а на прототипе С останется исходное значение
// z: 5. Для того чтобы поменять значение на самом прототипе С, понадобиться прописать ObjC.z = 10,

// console.log('objA', objA);

// console.log(objA.hasOwnProperty('x'));

// Ещё пример:

// const dummyObj = Object.create({ message: 'Это свойство объекта протортипа' });
// dummyObj.message = 'Это собственное свойство объекта';
// console.log('dummyObj', dummyObj);

// console.log(dummyObj.message);

//  'Это собственное свойство объекта'
//  'Это свойство на объекте-прототипе'

/*
 * Алгоритм поиска свойства в цепочке прототипов:
 * 1. Поиск начинается в собственных свойствах
 * 2. Если свойства нет в сообственных, поиск переходит к цепочке прототипов
 * 3. Поиск прекращается при первом совпадении (есть такое свойство)
 * 4. Возвращается значение свойства
 */

// const objA = Object.create({ z: 5 });
// objA.y = 100;
// console.log('objA', objA);

// console.log(objA.x);


// В итоге на этой концепции построено ООП (объектно ориентированное программирование)