/*
 * Функция это частный случай объекта -> ССЫЛОЧНЫЙ ТИП
 */

// console.log('[] === []: ', [] === []);
// console.log('{} === {}: ', {} === {});
// console.log(
//     'function() {} === function() {}: ',
//     function () {} === function () {},
// );

// const fnA = function () {
//     console.log('hello');
// };

// const fnB = fnA;
// console.log('fnB === fnA: ', fnB === fnA);

// Вывод: функция это сложный тип и по своей сутия является объектом.Когда мы передаем функцию, то как и
// массив или объект то мы на самом деле передаем ссылку на функцию. Т.е. функция имеет ссылочный тип данных.


/*
 * Контекст (this)
 *    - Где и как была объявлена функция НЕ ИМЕЕТ НИКАКОГО ВЛИЯНИЯ на контекст.
 *    - Контекст определяется В МОМЕНТ ВЫЗОВА ФУНКЦИИ, если он не привязан явно.
 */

// На контекст влияет то как ты вызвал функцию.Т.е.значение ключевого слова this записывается именно во время
// вызова функции.


/*
 * Как метод объекта. В контексте объекта.
 */

// const user = {
//     tag: 'Mango',
//     showTag() {
//         console.log('showTag -> this', this);
//     },
// };

// В коде выше контекст this не поределяется
// Значение this присваевается в коде ниже, т.е. в момент когда функция showTag() была вызвана.

// user.showTag();

// Разберем как это работает:
// 1. user.showTag(); - смотрит кто вызвал эту функцию ? Из выражения видно, что функция была вызвана в контексте
// объекта user (т.е. на объект который стоит слева от функции)
// 2. А user в свою очередь будеть ссылаться на запись в троке 40: console.log('showTag -> this', this), где указано
// слово this.
// Если слева от функции, метода стоит объект который её вызывает, то this в этой функции будет равняться этому
// объекту(будет ссылка на этот объект) Именно по этому мы используем не имя самого объекта а ключевое слово this.
// Функции и методы будут вызываться на объекте а this будет на него ссылаться.

// Это первое правило. Т.е. если this вызывается в контексте объекта указанного слева от вызываеой функции.
// Т.к.функция имеет ссылочный тип данных, то через объект указанный слева от функции по ссылке определяется this
// указанный в функции объявленной в исходном объекте user.

/*
 * Вызов без контекста
 * - В строгом режиме = undefined
 * - Не в строгом режиме = window
 */

// const foo = function () {
//     console.log('foo -> this', this);
// };

// foo();

/*
 * Как метод объекта, но объявлена как внешняя функция.
 * В контексте объекта.
 */

// const showTag = function () {
//     console.log('showTag -> this', this);
//     console.log('showTag -> this.tag', this.tag);
// };

// showTag();

// В примере выше тоже будет undefined, т.к.сама функция объявлена, но она не объявлена внутри какого-то объекту и
// ссылки на какой либо объект у неё тоже нет.

// const user = {
//     tag: 'Mango',
// };

// user.showUserTag = showTag;
// console.log('user', user);


// В записи user.showUserTag = showTag; - мы записываем в свойство объекта ссылку на внешню функцию, т.е.
// связываем ранее объявленную внешнюю функцию и наш объект.
// А здесь(в строке 93) все ок, т.к.:
// В объект user на свойство showUserTag мы записываем ссылку на функцию showTag. См. - user.showUserTag = showTag;
// т.е.на функцию которая объвлена в строках 80 - 81 в переменной showTag(стр.79) В резльтате выводя в консоль
// параметр user - console.log('user', user); мы видем ссылку на значение переменной user (строки 89-91).

// user.showUserTag();

// А здесь в строке 104 при вызове функции showUserTag мы теперь видем как она ссылается на this обїявленной в
// переменной showTag.
// Как это работает ?:
// На свойстве user создали свойство showUserTag() и записали в него ссылку "showTag" на оригинальную функцию в
// строке 79. После чего мы вызываем метод(свойство): user.showUserTag(); в котором лежит ссылка на оригинальную
// функцию, которая вызвалась в контексте user, которая была указана слева от.showUserTag(), соответственно её
// this присваеватся обїекту который её вызвал. Вывод, контекст(значение) this определилось только в 104 строке.

/*
 * Вызов без контекста, но объявлена как метод объекта.
 */

// const user = {
//     tag: 'Mango',
//     showTag() {
//         console.log('showTag -> this', this);
//         console.log('showTag -> this.tag', this.tag);
//     },
// };

// user.showTag();

// Разберем пример выше:
// У объекта user внутри есть метод showTag().Метод - єто просто какая то функция, которая лежит в свойстве под
// именеи showTag.Если мы вызываем user.showTag(стр.126) что происходит ? Функция showTag описанная в строках 120 -
// 122, была вызвана в контексте объекта user указанного слева от функции.И ссылка на этого user запишется в this.
    

// Теперь такой вариант, объявляем внешнюю переменную outerShowTag, в которую присвоим ссылку на user.showTag.
// Т.е. в переменную outerShowTag мы записываем ссылку на функцию user.showTag объявленную в 120-122 строках.

// const outerShowTag = user.showTag;
// Если записать вот так: const outerShowTag = user.showTag(); то в переменной лежал бы результат работы функции
// showTag; а при такой записи const outerShowTag = user.showTag; мы просто говорим что переменная const outerShowTag
// равна функции user.showTag, т.е. мы просто сделали ссылку на функцию.

// Поэтому если мы далее её вызовем:
// outerShowTag();

// В результате: когда мы вызываем переменную outerShowTag() интерпретатор спрашивает, что лежит в этой
// перемнной ? В ней лежит функция, он её вызывает, выполняется тело оригинальной функции showTag(описанной в
// строках 120 - 122) и далее спрашивает а какой в ней this ? Кто тебя вызывает, там есть какой то объект ? Нет,
// ты не в контексте объекта вызываешься поэтому в this определится undefined.Если бы мы слева указали объект
// user было бы ок. Т.е. описанная запись ошибочная, так делать нельзя.

// Если бы ы записали так: user.outerShowTag() - то результат был бы undefined, т.к.интерпретатор взял бы объект
// user пошел бы в переменную на строке 118 - 124 посмотрел бы что на этом объекте нет такой функции(метода) и
// вернул бы ошибку.По сути outerShowTag() это какая то внешняя независимая переенная, которая не имеет связи
// с объектом user, т.е. на объекте user нет такого свойства.

/*
 * Контекст в callback-функциях
 */
// Разберем ещё один юзкейс:

// У нас есть стандартный наш объект в котором лежит функция showTag():
const user = {
    tag: 'Mango',
    showTag() {
        console.log('showTag -> this', this);
        console.log('showTag -> this.tag', this.tag);
    },
};

// Стандартный вызов функции, которая имеет контекст, в результате вернется корректное значение:
// user.showTag();

// При такой записи:
// const abc = user.showTag; // это просто ссылка на оригинал функции
// abc();
// user.abc(); // и так тоже this будет андефайнд
// Результат будет андефайнд т.к.это не связанная внешняя переменна, которая вызывается не в контексте объекта
// user. Такого свойства на объекте user не существует.

// Теперь усложним процесс и запишем ещё одну функцию invokeAction, которая ожидает какой то экшн. А точнее
// ожидает колбэк (действие):

// const invokeAction = function (action) {
//     console.log(action);

//     action(); // здесь мы вызываем колбэк
// };

// Здесь в() мы передаем аргумент, а именно в функцию invokeAction в парметр(action) - см.строку 183, передаем
// ссылку на функцию showTag:

// invokeAction(user.showTag);
// это та же ошибка что и :
// user.invokeAction - будет undefine

// Буквально во время вызова user.showTag в строке 192, в(action) на строке 183 записывается ссылка на функцию
// описанную в страх 164-167 и потом эта функция вызывается в строке 186

// В результате в this будет андефайнд, т.к. в стр186 функция action() вызывается вне какого либо контекста.
// А в строке 192 в invokeAction(user.showTag) лежит просто ссылка на user.showTag и всё.У самого объекта
// user такого свойства как action просто нет (по аналогии с предыдущим примером будет undefined)

// Сам по себе метод объекта showTag вне объекта user ничего не знает про user.Вызов функции во вне даст
// положительный результат, только тогда когда мы точно укажем showTag связку с объектом user, т.е.запишем
// user.showTag - в такой записи интерпретатор понимет в каком объекте проверить функцию, пойдёт и найдёт её.

// Контекст - это то внутри (в контексте) какого объекта они вызываются

/*
 * Тренируемся 1
 */

// const fn = function () {
//     console.log('fn -> this', this);
// };

// fn(); // Какой this ???
// Думаю будет this window. Но нет будет undefined т.к. вызвалась без привязки к контексту


/*
 * Тренируемся 2
 */

// const book = {
//     title: 'React for beginners',
//     showThis() {
//         console.log('showThis -> this', this);
//     },
//     showTitle() {
//         console.log('showTitle -> this.title', this.title);
//     },
// };

// book.showThis(); // Какой this ??? Корректно, вернет title: 'React for beginners' и все функции в объекте

// const outerShowThis = book.showThis;
// outerShowThis(); // Какой this ??? - undefined т.к. такого свойства нет на объекте book

// const outerShowTitle = book.showTitle;
// outerShowTitle(); // Какой this ??? - undefined т.к. такого свойства нет на объекте book

/*
 * Тренируемся 3
 */

// const makeChangeColor = function () {
//     const changeColor = function (color) {
//         console.log('changeColor -> this', this);
//         // this.color = color;
//     };

    // changeColor(); // Какой this ??? Вернет undefinded т.к. функция вызывается на функции у которой нет объекта

//     const sweater = {
//         color: 'teal',
//     };

//     sweater.updateColor = changeColor;

//     sweater.updateColor('red'); // Какой this ??? Вернет ссылку на sweater 

//     return sweater.updateColor;
// };

// const swapColor = makeChangeColor();

// swapColor('blue'); // Какой this ??? вернет undefined. Почему?

// Разберем: Вызывается makeChangeColor() в 266 строке при которой выполняется оригинальная функция
// makeChangeColor в 247 строке, ссылка на эту функцию из 247 строки записывается в updateColor на 259 строке,
// т.е.теперь в updateColor на 259 строке теперь лежит ссылка на оригинальную функцию из 247 строки.После чего
// из makeChangeColor на 266 строке мы возвращаем ссылку на функцию sweater.updateColor которая лежит в 263
// строке.Получается что в переменную const swapColor записывается (через return sweater.updateColor;)
// ссылка на оригинальную функцию из 247 строки.После чего эта оригинальная функция без какого либо объекта
// вызывается в строке 268: swapColor('blue'); Кроме того что здесь не указан сам объект, важно ещё хорошо
// понимать последовательность вызова функций(т.е.что откуда и куда вызывается).Ясно читать и понимать смысл
// и поледовательность действий.В нашем примере идёт сквозная ссылка на оригинальную функцию через все функции
// к последней функции в строке 268. Это специально запутанный пример чтобы разобраться.

// ВАЖНО понимать суть и логику того как и что делается, таой спец.ценится, если просто уметь чтото делать и при
// этом не понимать как, то это тупик

/*
 * Тренируемся 4
 */

// const makeChangeColor = function () {
//     const changeColor = function (color) {
//         console.log('changeColor -> this', this);
//     };

//     return changeColor;
// };

// const updateColor = makeChangeColor();
// updateColor('yellow'); // Какой this ??? Undefined по аналогии с предыдущим приером. Цепочка ссылок на 
// // орегинальную функцию без привязки  объекту

// const hat = {
//     color: 'blue',
//     updateColor,  // здесь применили короткую запись, что равносильно записи = updateColor: updateColor (вспоминаем если переенна идентична названию свойства объекта, то можем использовать короткую запись)
// };

// hat.updateColor('orange'); // Какой this ?? Вернет значение, т.к. есть контекст на объект hat и ссылка на 
// оригинальную функцию по цеопчке от updateColor до changeColor из оригинальной функции makeChangeColor

/*
 * Тренируемся 5
 */

const counter = {
    value: 0,
    increment(value) {
        console.log('increment -> this', this);
        this.value += value;
    },
    decrement(value) {
        console.log('decrement -> this', this);
        this.value -= value;
    },
};

const updateCounter = function (value, operation) {
    operation(value); // Какой this ???
};

updateCounter(10, counter.increment);
updateCounter(5, counter.decrement);

// В обеих случаях будет undefined.Потому что при передаче метода объекта как колбэка(см.строки 328 и 329) - это
// параметры counter.increment и counter.decrement контекст не сохраняется. В итоге мы передаем ссылку на 
// какую то рандомную функцию в памяти, которая ничего не знает про объект который хранит эти функции.
// Правило - при передаче методов объектов как колбэк, контекст не сохраняется.