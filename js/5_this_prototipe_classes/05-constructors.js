/*
 * Основы ООП: класс, экземпляр (объект), интерфейс
 */

/*
 * Функции-конструкторы
 * - Именование
 * - Оператор new
 * - Свойство Function.prototype
 */

// ДЛЯ СОБЕСЕДОВАНИЯ ЭТА ТЕМА СУПЕР ВАЖНАЯ, НЕОБХОДИМО ЧЁТКО И ПО ПОЛОЧКАМ В НЕЙ РАЗБИРАТЬСЯ!!! ТАК ЖЕ
// КАК И ТЕМА КОНТЕКСТ THIS!!! БЛАГОДРАЯ ЭТИМ ТЕМАМ В JS РАБОТАЕТ ВСЁ!!! ЗНАТЬ ОБЯЗАТЕЛЬНО!!!

// Функция конструктор, это самая обычная функция, но должна быть: а) с большой буквы, б) существительным в
// единственном числе. С БОЛЬШОЙ БУКВЫ НАЗЫВАЮТСЯ ТОЛЬКО ПЕРЕМЕННАЯ ДЛЯ ФУНКЦИИ КОНСТРУКТОРА (КЛАССОВ) !!!

// Как сделать экземпляр по классу(т.е. по конструктору)?:
// const Car = function () { }; // объявили функцию конструктора
// const myCar = new Car(); // создае экземпляр на базе конструктора. Здесь ключевым будет оператор new, он
// ответственный за создание экземпляра
// В результате вызова мы получим новый объект, который является экземпляром класса Car:
// console.log(myCar);

// Разберемся как работает эта функция конструктор:
// 1. Если функция вызывается через new создается пустой объект и хранится где-то в паяти.
// 2. Функция вызывается в контексте созданного объекта, то есть в this записывается ссылка на него
// 3. В свойство this.__proto__ записывается ссылка на обьект Car.prototype тоесть Car.prototype
// это ПРОТОТИП будущего обьекта(экземпляра)
// 4. Ссылка на обьект возвращается в место вызова new Car

// _____________________________________________________________________________________________________________

// Разберем лекцию по-шагово. Исходник лекции лежит ниже после детального разбора:

// Перепишем исходный пример начисто и опишем пошагово его алгоритм выполения:

// const Car = function () {
  // console.log(this);
// };

// const myCar = new Car();

// Функция Car будет вызываться в контексте создаваемых объектов. Это значит, что внутри неё, во время вызова
// (пример вызова const myCar = new Car(); или см.строку 144) this будет ссылаться на этот пустой созданный
// объект. В итоге: Создался пустой объект и функция в его контексте вызвалась или её this ссылается на этот
// вновь созданный объект.

// const myCar = new Car(); - это просто пустой объект, а const Car = function () { }; в его контексте вызывается

// Это можн проверить выведя в консоль вновь созданный объект:
// console.log(myCar);

// На этот вновь созданный объект мы можем добавлять произвольные свойства в любом кол-ве (но добавляем их
// прямиком в конструктор функцию, эти свойства передадуться в объект который будет вызывать через new функцию
// конструктор Car(), т.е. в const myCar)

// const Car = function () {
  // console.log(this);

// this.a = 555;
// };

// Не смотря на то что this лежит в функции "Car"(строка 163) ссылка на объект "myCar" возвращается в место
// вызова т.е. в new Car() в записи myCar = new Car()

// Таким образом: создается пустой объект(myCar) функция вызыватся в его контексте через new Car(), мы на этот
// объект накидываем каких - то свойств, после того как функция отработала, ссылка на этот объект возвращается
// на место её вызова т.е.на new Car() через оператор "new" и в результате в переменной const myCar мы имем
// результат этого класса или объект со свойствами.К примеру это свойство this.a = 555;
// Проверим законсолив console.log(myCar); Получается в итоге так, что в функцию конструктора мы накидываем
// нужное количество свойст, но передаем их в тот объект который создали через new Car().Благодаря оператору
// new происходит передача свойств созданных в функции конструктора на нужный нам объект.

// В функцию можем передавать аргументы, к примеру:

// const Car = function (value) {
// console.log(this);
// this.a = value;
// };

// const myCar1 = new Car(5);
// console.log(myCar1); // в myCar1 в свойство а запишется значение - 5.

// Разберем как это работает ещё и на этом примере:
// В выражении const myCar1 = new Car(5); через new вызывается функция Car(), при этом создается пустой объект
// myCar1 далее функция Car вызвалась в контексте этого объекта(т.е.this(стр 183)) ссылается на данный объект.
// Car(5) - значение 5 передается в функцию и подставляется в параметр value в функции const Car = function (value)
// Когда выполняется this.a = value; на этом объекте myCar1 по ссылке создается свойство "а", в которое
// записывается значение указанное в аргументе new Car(5).Когда функция закончила свое исполнение ссылка на этот
// объект возвращаетя на место её вызова, а именно в выражение const myCar1 = new Car(5) и таким образом
// записывается в переменную const myCar1 ссылка на этот объект и в результате мы видем в консоле Car {a: 5}
// обычный синтаксис вызова функции это: Car(5); а когда мы вызываем функцию с оператором new: new Car(5); то
// происходит вот эта вся магия с созданием объекта, вызова функции сразу в контексте.
// В итоге используя классы(или конструктор функции) мы можем описать какую то сущность, внутри неё используя
// this определить набор характеристик(в нашем примере только одна this.a = value;, но далее посмотрим ещё
// пример) и потом передавать разные значения в результате у нас получается целая фабрика объектов.
// И так каждый раз когда мы вызываем функцию Car через new для других переменных, пример другие машины ниже:
// const myCar2 = new Car(10);
// console.log(myCar2);
// или
// const myCar3 = new Car(7);
// console.log(myCar3);

// Напишем ещё пример с использованием автомобилей и их характеристик:

// const Car = function ({ brand, model, price }) - brand, model, price - это параметры для функции
// const myCar1 = new Car('Audi', 'Q3', '35000'); - 'Audi', 'Q3', '35000' - это аргументы функции

// const Car = function (brand, model, price) {
// // опишем свойства наших машин:
//   this.brand = brand;
//   this.model = model;
//   this.price = price;
// }

// const myCar1 = new Car('Audi', 'Q3', '35000');
// console.log(myCar1);

// Если у нас в параметрах функции два и более параметра, то лучше передавать объект настроек, поэтому
// переделаем нашу функцию так:

// const Car = function (config = {}) {
//   // console.log(config);
//   this.brand = config.brand;
//   this.model = config.model;
//   this.price = config.price;
// }

// вместо config можно использовать любое другое слово, это просто имя параетра(в итоге переделаем т.к.такая
// запись не очень)
// (config) - при такой записи объекта настроек, если у объекта будут не определены аргументы, то в коде выдаст
// ошибку
// (config = {}) - это запись параметров по умолчанию из пустого объекта, если аргументы в объекте будут
// пустыми то запишется undefined для каждого свойства

// const myCar1 = new Car({
//   brand: 'Audi',
//   model: 'Q3',
//   price: '35000'
// });
// console.log(myCar1);

// const myCar2 = new Car({
//   brand: 'BMW',
//   model: 'X6',
//   price: '50000'
// });
// console.log(myCar2);

// const myCar3 = new Car();
// console.log(myCar3);

// Далее, как можно улучшить и оптимизировать нашу функцию ? Если нам в функцию приходит объект, мы можем
// его деструктуризировать:

// Можем сделать так:
// const Car = function (config = {}) {
//   const { brand, model, price } = config; // деструктуризация свойств
//   this.brand = brand;
//   this.model = model;
//   this.price = price;
// }

// Или можем сразу в параметрах:

// const Car = function ({ brand, model, price } = {}) {
//   this.brand = brand;
//   this.model = model;
//   this.price = price;
// }

// const myCar1 = new Car({
//   brand: 'Audi',
//   model: 'Q3',
//   price: '35000'
// });
// console.log(myCar1);

// В итоге ещё раз опишем логику:
// В строке 278 Вызываем функци new Car(), через new, создается пустой объект myCar1, при этом функция Car()
// вызывается в контексте объекта myCar1 который ещё пустой, далее этой функции аргументом (строки 279-281)
// передаются({ brand: 'Audi', model: 'Q3', price: '35000' }); значения в функцию Car строка 272. и далее
// строки 273 - 275 внутри функции во время её вызова из строки 278 ссылается на тот пустой объект который её
// вызвал(т.е.myCar1), после чего наполняем этот объект тремя свойствами из функции(стр. 273 - 275), который
// в свою очередь взяли из стр. 279 - 281. Когда функция закончила работу, ссылка на тот объект который
// создался возвращается на стр 278, т.е. в myCar1 лежит ссылка на новосозданный экземпляр.

// const myCar2 = new Car({
//   brand: 'BMW',
//   model: 'X6',
//   price: '50000'
// });
// console.log(myCar2);

// const myCar3 = new Car();
// console.log(myCar3);

// Далее попробуем создать метод, который будет менять нам цены на эти объекты, для этого в функцию допишем
// новый метод

// const Car = function ({ brand, model, price } = {}) {
//   this.brand = brand;
//   this.model = model;
//   this.price = price;

//   this.changePrice = function (newPrice) {
//     this.price = newPrice;
//   };

// };

// const myCar1 = new Car({
//   brand: 'Audi',
//   model: 'Q3',
//   price: '35000'
// });
// console.log(myCar1);

// const myCar2 = new Car({
//   brand: 'BMW',
//   model: 'X6',
//   price: '50000'
// });
// console.log(myCar2);

// const myCar3 = new Car({
//   brand: 'Audi',
//   model: 'A6',
//   price: '75000'
// });
// console.log(myCar3);

// После добавления функции changePrice на класс(в конструктор функции), у нас автоматом добавилась не ссылка
// а копия этой функции на каждый объект "myCar", который мы создали через "new Car()". Важно, то что мы
// добавили в конструктор функции передается в объекты которые мы создаем в виде копии (не ссылки).
// Ещё раз: все что мы объявляем внутри тела конструктора функции, передается как копия на экземпляр(объект),
// который создается через new.

// Если добавлять методы(функции) в тело функции конструктора, то на каждо экзепляре будет создаваться пачка
// копий этих методов которые мы на создавали в теле функции конструктора.Чтобы такого небыло, сначал создаем
// функцию конструктор.А потом вне функции создаем доп.методы(функции), которые можно будет использовать
// вызывая через экзепляр.
// Ещё раз приведу приер создания доп.метода для функции конструктора за пределаи её тела:

// Car.prototype.changePrice = function (newPrice) {
//   this.price = newPrice;
// };

// Далее:
// у каждого объекта есть свойство __proto__
// у каждой функции есть свойство "prototype" или объект { constructor: f }, кроме стрелок т.к.они не
// // могут быть конструкторами.
// В итоге получается что в свойство __proto__ записывается ссылка на свойство функции "prototype".
// В нашем примере: на this.__proto__ записывается ссылка на Car.prototype.
// Т.Е. ОБЪЕКТ, КОТОРЫЙ ЛЕЖИТ В Car.prototype ЭТО ПРОТОТИП БУДУЩЕГО ЭКЗЕПЛЯРА.

// Распишем цепочку:
// 1. вызывается new Car() к примеру (const myCar1 = new Car()) в результате чего создается пустой объект
// 2. функция new Car() вызывается в контексте нового объекта myCar1, соответственно this теперь ссылается на
// myCar1, после чего ему по ссылочке записываются все свойства(бренд, модель, прайс), в том числе ему
// автоматически добавляется свойство __proto__ которое ссылается на Car.prototype (т.е. на объект { constructor: f })
// Получается что прототип устанавливается сразу при создании экземпляра(объекта созданного через
// оператор new Car()).Далее мы може использовать этот объект Car.prototype, чтобы добавить какие то общие
// методы(функции), которые унаследуют все прототипы(объекты) на свойство __proto__
// В итоге получается что: все свойства из конструктора функции передаются на экземпляры через this при создании
// прототипа(объекта) через оператор new, в нашем случае new Car().В тоже время на этих экземплярах создаются
// автомато свойство __proto__ куда по ссылке из конструктора функций передаются все етоды(функции) созданные
// на конструкторе функций, через свойство prototype, в наше случае Car.prototype.

// Для примра добавим новую функцию в тело конструктора функции:

// Car.prototype.sayHi = function () {
//   console.log('Car.prototype.sayHi -> this', this);
//   console.log('Hello :) ');
// };

// Car.prototype.changePrice = function (newPrice) {
//   this.price = newPrice;
// };

// console.log(Car.prototype);

// После добавления новых методов в тело конструктора функции, мы увидем на объектах(экземплярах) в свойстве
// __proto__ эти методы (функции), которые по ссылке передались из свойства Car.prototype конструктора функции.

// const myCar = new Car({
//   brand: 'Audi',
//   model: 'Q3',
//   price: 35000,
// });
// console.log(myCar);


// myCar.sayHi();

// // Поменяем прайс:
// myCar.changePrice(10000);

// Как это работает ? Распишем логику: Наш автомобиль myCar вызывает функцию .changePrice, интерпретатор
// проверяет есть ли у объекта такое свойство ? Нет.Идёт далее и проверяет в __proto__ есть т.к.в нем лежит
// ссылка на свойство Car.prototype в котором лежит эта функция.Поэтому вызывает эту функцию через this в
// контексте myCar.

// Если добавлять методы(функции) в тело функции конструктора, то на каждо экзепляре будет создаваться пачка
// копий этих методов которые мы на создавали в теле функции конструктора.Чтобы такого небыло, сначал создаем
// функцию конструктор.А потом вне функции создаем доп.методы(функции), которые можно будет использовать
// вызывая через экзепляр.
// Ещё раз приведу приер создания доп.метода для функции конструктора за пределаи её тела:

// Car.prototype.changePrice = function (newPrice) {
//   this.price = newPrice;
// };

// В результате получается что на свойстве prototype будет создано некое хранилище методов которые будут
// использоваться каждым созданным экземпляром.

// const myCar2 = new Car({ brand: 'BMW', model: 'X6', price: 50000 });
// console.log(myCar2);

// myCar2.sayHi();

// const myCar3 = new Car({ brand: 'Audi', model: 'A6', price: 65000 });
// console.log(myCar3);

// myCar3.sayHi();


// Ещё один пример:

// const User = function ({ email, password } = {}) {
//   this.email = email;
//   this.password = password;
// };

// console.log(User.prototype);

// User.prototype.changeEmail = function (newMail) {
//   this.email = newMail;
// };

// const mango = new User({ email: 'mango@mail.com', password: 1111111 });

// mango.changeEmail('my-new-mail@mail.com');
// console.log(mango);

// /*
//  * Статические свойства и методы
//  * - Статические свойства и методы доступны только на самом конструкторе
//  * - В статических методах не нужен this
//  */

// Пример статического свойства и метода доступного только на конструкторе(мы видем что свойство записано с
// за главной буквы). Это встроенные свойства и методы, которые лежат на самом конструкторе они не передаются
// на экземпляры и на них не работают this, точнее работаю но они ссылаются сами на себя:
// console.log(Math.round(5.1));
// console.log(Math.PI);

// Эти свойства и методы тоже вспомогательные:
// Object.keys()
// Object.value()

// User.message =
//   'Я статическое свойство, меня нет на экземплярах или в прототипе.';

// User.logInfo = function (obj) {
//   console.log('User.logInfo -> obj', obj);
//   console.log('Почта: ', obj.email);
//   console.log('Пароль: ', obj.password);
// };

// User.logInfo(mango);

// Подведем итоги:
// 1. У каждого обьекта есть свойство __proto__
// 2. В этом свойстве лежит ссылка на его ПРОТОТИП, то есть другой обьект
// 3. При создании литера обьекта, в свойство __proto__ записывается ссылка на Функция.prototype
// 4. Функция-конструктор это просто функция :)
// 5. Всю магию делает оператор new
// 6. Если функция вызывается через new, создаётся пустой объект
// 7. Функция вызывается в контексте созданного объекта
// 8. В свойство this.__proto__ записывается ссылка на обьект Функция.prototype
// 9. Ссылка на обьект возвращается в место вызова new Фунукция()

// _____________________________________________________________________________________________________________

// Исходник лекции:

// const Car = function ({ brand, model, price } = {}) {
  // const { brand, model, price } = config;
  // 2. Функция вызывается в контексте созданного объекта,
  //    то есть в this записывается ссылка на него
  // this.brand = brand;
  // this.model = model;
  // this.price = price;

  // 3. В свойство this.__proto__ записывается ссылка на обьект Car.prototype
  //    тоесть Car.prototype это ПРОТОТИП будущего обьекта (экземпляра)

  // 4. Ссылка на обьект возвращается в место вызова new Car
// };

// Пропишем логику и последовательность:
// 1. На новом экземплре(к примеру const myCar) вызывается newCar, в результате чего создается пустой объект,
//   функия создается в контектсе объекта myCar, поэтому this из функции newCar ссылается на него в результате
// чего новому объекту из функции передаются по ссылке все свойства(бренд, модель, прайс), в том числе ему
// добавляется свойство __proto__ которое сылается на Car.prototype(см.стр. 61) Получается что прототип
// устанавливаетс разу после создания экземпляра.Мы можем использовать объект Car.prototype для того чтобы
// добавить какие то общие методы.
// Свойство prototype есть только у функций. В нашем случае на функции Car. У объектов это будет свойство
// __proto__ И вот эта связь свойства функции prototype и свойства объекта __proto__ выполняется автоматом во
// время вызова функции new Car при создании экземпляра myCar.

// На свойство функции "prototype" мы можем записать безконечно кол - во свойств и методов, которые будут по
// ссылке распространяться на все объекты в контексе которых будет вызываться функция конструктор, в нашем
// случае  "Car". В результате такого подхода мы получаем хранилище свойств и методов, которые с легкостью
// могут быть переиспользованы при создании экземпляров

// К примеру:

// Car.prototype.sayHi = function () {
//   console.log('Car.prototype.sayHi -> this', this);
//   console.log('Hello :) ');
// };

// Car.prototype.changePrice = function (newPrice) {
//   this.price = newPrice;
// };

// console.log(Car.prototype);

// 1. Если функция вызывается через new, создаётся пустой объект
// const myCar = new Car({
//   brand: 'Audi',
//   model: 'Q3',
//   price: 35000,
// });
// console.log(myCar);

// myCar.sayHi();
// myCar.changePrice(10000);

// const myCar2 = new Car({ brand: 'BMW', model: 'X6', price: 50000 });
// console.log(myCar2);

// myCar2.sayHi();

// const myCar3 = new Car({ brand: 'Audi', model: 'A6', price: 65000 });
// console.log(myCar3);

// myCar3.sayHi();

// const User = function ({ email, password } = {}) {
//   this.email = email;
//   this.password = password;
// };

// console.log(User.prototype);

// User.prototype.changeEmail = function (newMail) {
//   this.email = newMail;
// };

// const mango = new User({ email: 'mango@mail.com', password: 1111111 });

// mango.changeEmail('my-new-mail@mail.com');
// // console.log(mango);

// /*
//  * Статические свойства и методы
//  * - Статические свойства и методы доступны только на самом конструкторе
//  * - В статических методах не нужен this
//  */

// User.message =
//   'Я статическое свойство, меня нет на экземплярах или в прототипе.';

// User.logInfo = function (obj) {
//   console.log('User.logInfo -> obj', obj);
//   console.log('Почта: ', obj.email);
//   console.log('Пароль: ', obj.password);
// };

// User.logInfo(mango);

// Object.keys()
// Object.value()

// 1. У каждого обьекта есть свойство __proto__
// 2. В этом свойстве лежит ссылка на его ПРОТОТИП, то есть другой обьект
// 3. При создании литера обьекта, в свойство __proto__ записывается ссылка на Функция.prototype
// 4. Функция-конструктор это просто функция :)
// 5. Всю магию делает оператор new
// 6. Если функция вызывается через new, создаётся пустой объект
// 7. Функция вызывается в контексте созданного объекта
// 8. В свойство this.__proto__ записывается ссылка на обьект Функция.prototype
// 9. Ссылка на обьект возвращается в место вызова new Фунукция()