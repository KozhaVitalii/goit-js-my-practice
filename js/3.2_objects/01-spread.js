/*
 * Операция spread (распыление)
 * - Array.prototype.concat() и аналог через spread
 */

// Метод concat ничего не изменяет в массиве, просто позволяет объединить несколько массивов в один новый массив:
// const numbers = [1, 2, 3].concat([4, 5, 6], [7, 8, 9]);

// Есть более современный синтаксис который позволяет работать с массивами / объектами.Ранее мы уже рассматривали
// операцию rest, которая позволяет объединять массивы.Синтаксис "..." у операции rest и spread одинаковый. И в
// зависимости от того где поставить синтаксис "..." будет операция распыления или сбора.
// Операции spread и rest не являются деструктивными, т.е. не изменяют исходник, а на основе его создается копия,
// (если речь идёт о примитивных типах данных) и создается ссылка (если речь идёт о сложных типах данных (
// когда в массиве есть к примеру объекты) и в ней уже производятся изменения.

// К примеру, вариант распыления массива:
// const numbers = [...[1, 2, 3], 4, 5] // где в результате получится 1,2,3,4,5
// или такой вариант:
// const numbers = [0, 5, 10,...[1, 2, 3], 4, 5] // где в результате получится 0, 5, 10, 1, 2, 3, 4, 5
// console.log(numbers);
// Как видим выполняется распыление именно массива[1, 2, 3] и элементы массива становятся в новом массиве в том
// порядке в котором указано "..."
// к примеру ещё такой вариант:

// const numbers = [...[0, 5, 10],...[1, 2, 3], ...[4, 5]] // где в результате получится [0, 5, 10, 1, 2, 3, 4, 5]
// console.log(numbers);

// Это и есть распыление (spread), его задача взять коллекцию массива и распаковать её в другую коллекцию. Это
// аналог concat(), только при concat() происходит объединение массивов, а в данном случае происходит распыление
// (под распыляет подразумевается добавляет в другой массив) всего содержимого массива, в котором могут быть
// как отдельные элементы так и массивы: [0, 5, 10, ...[1, 2, 3], 4, 5]

// Ещё вариант:
// const numbers = [
//   1000,
//   ...[1, 2, 3],
//   5000,
//   ...[4, 5, 6],
//   7000,
//   ...[7, 8, 9],
//   9000,
// ];

// console.log(numbers);

/*
 * Поиск самой маленькой или большой температуры (числа)
 */
// const temps = [18, 14, 12, 21, 17, 29, 24];

// Метод позволяющий выбрать в массиве самое большое число:
// console.log(Math.max(1, 4, 17, 5, 6));
// Либо самое маленькое:
// console.log(Math.min(1, 4, 17, 5, 6));

// В примере выше, мы обращались именно к ряду элементов (не массиву), если нам необходимо обратить непосредственно к
// переменной(именно к массиву), то чтобы операция Math.min(либо min) выполнилась нам необходимо распылить
// массив, а именно перед массивом указать синтаксис "...", который характеризует метод spread:
// console.log(Math.min(...temps));
// console.log(Math.max(...temps));
// console.log(temps);

// В данном случае (а и b) выполняется не копия объекта а создается ссылка на оригинал:
// const a = [{ x: 1 }, { y: 2 }, { z: 3 }];
// В массив b распыляется массив а:
// const b = [...a];

// console.log('a: ', a);
// console.log('b: ', b);

// console.log(a[0] === b[0]);
// console.log(a === b);

// a[0].x = 1000;

// console.log('a: ', a);
// console.log('b: ', b);

/*
 * Сшиваем несколько массивов в один через concat() и spread
 */
// const lastWeekTemps = [1, 2, 3];
// const currentTemps = [4, 5, 6];
// const nextWeekTemps = [7, 8, 9];

// Выполняем объединение через concat:
// const newarray = lastWeekTemps.concat(currentTemps, nextWeekTemps);

// Выполняем распыления через операцию spread. Привыкаем юзать именно операцию spread:
// const allTemps = [...lastWeekTemps, ...currentTemps, ...nextWeekTemps];
// console.log(allTemps);

// С распылением массивов разобрались, теперь разберем особенность распыления объектов:

/*
 * Распыление объектов
 * - Object.prototype.assign() и spread
 */
// Распыление объектов выполняется по аналогии с массивом, при одном исключении, при объединении массивов
// элементы могут повторяться, а вот при объединении объектов, свойства объектов повторяться не могут, в
// результате объединения двух одинаковых свойств объектов в новый объект запишиться то свойство, которое
// стоит ниже в коде или последним.

const a = { x: 1, y: 2 };
const b = { x: 0, z: 3 };

// Ранее делали так: где в { } указівали тот объект в который хотим распылить другие объекты, к примеру а и b:
// const c = Object.assign({}, a, b);
// console.log(c);
// В результате получаем: {x: 0, y: 2, z: 3}, как видим в x подставилось последнее значение (а именно из
// объекта b), т.к.свойство стоит правее x: 1. Свойства в объекте могут быть уникальными и не могут повторятся,
// по этому происходит замена х на последнее значение

// Более современная запись будет выглядеть так:
// const c = {
//   ...a,
//   ...b,
// };
// console.log(c);

// const c = Object.assign({ name: 'Mango' }, a, b);

// В данном случае сначала идёт свойство объекта, а потом идёт распыление:
// const c = {
// name: 'Mango',
//   ...a,
//   ...b,
// };

// ну или так:
// const c = {
//   ...a,
// name: 'Mango',
//   ...b,
// };
// console.log(c);


// Поэкспериментируем:
// const c = {
//   ...a,
//   x: 10,
//   ...b,
//   y: 20,
// };
// console.log(c);
// В результате видим { x: 0, y: 20, z: 3 }, х = 0, т.к.бьерется самый последний в коде из b, y = 20 т.к.он
// самій последний в коде (а значит значение у из переменной а будет перезаписано)


// Разберём живой пример:
// Есть какие-то настройки интерфейса сайта по умолчанию прям в браузере: 
const defaultSettings = {
  theme: 'light',
  showNotifications: true,
  hideSidebar: false,
};

// Мы добавляем какие-то свои персональные настройки: 
const userSettings = {
  showNotifications: false,
  hideSidebar: true,
};

// Наша задача объединить дефолтные и персональные настройки в общие итоговые настройки сайта:
Сливаем объекты в один финальный объект через операцию 

const finalSettings = {
  ...defaultSettings,
  ...userSettings,
};

// В итоге видим что в финальных настройках значения   showNotifications переопределилось с true на false,  а hideSidebar: с false на true:
console.log(finalSettings);
