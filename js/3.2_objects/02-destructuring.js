/*
 * Деструктуризация объекта
 * - Значения по умолчанию
 * - Имя переменной отличное от имени свойства
 */

const playlist = {
  name: 'Мой супер плейлист',
  rating: 5,
  tracks: ['трек-1', 'трек-2', 'трек-3'],
  trackCount: 3,
};

// Учимся разархивировать или распаковывать объекты и массивы.Большинство данных с которыми предстоит работать
// это обычные объекты с набором свойств.Для того чтобы максимально оптимально обращаться к свойствам объекта
// есть такой метод как деструктуризация(или распаковка) объекта.
// const {} = playlist // Если фигурные скобки {} стоят слева от объекта (от равно) - это признак операции
// деструктуризации объекта. Если мы видим такую запись: const [] = [1,2,3] - то это деструктуризация массива.

// const { rating } = playlist; - после равно может быть только один объект!
// Таким образом мы создали локальную переменную, которая создана на основе
// свойства объекта
// console.log(rating);
// Если мы хотим вытащить из объекта две или несколько переменных мы указываем так:
// const { rating, tracks, name, trackCount } = playlist;
// console.log(rating, tracks, name, trackCount);
// Это и называется распаковка (разархивирование) или деструктуризация объекта
// !!!Первое правило при деструктуризации объекта это имя свойства должно точно совпадать с именем переменной.
// !!!Деструктуризация нужна ещё для того чтобы в локальные переменные вытянуть значения свойств объекта и далее
// удобно с ними работать в своем коде.Не писать playlist.rating, playlist.tracks и т.д., а иметь для работы свои
// независимые переменные.
// Если меняются значения свойств объекта, то значения в локальных переменных будут зависить от того какой тип
// данных используется в объекте.Если передаваемое свойство объекта имеет примитивный тип данных, то при изменении
// значения в локальной переменной в свойстве объекта значение не поменяется, т.к.в локальную переменну изначально
// скопировалось значение свойства и далее его можно менять в лок.переменной без изменения значения в свойстве
// объекта.К примеру, если мы в локальную переменную rating(которая изначально содержит исходное значение 5),
// запушим(rating.push(3) новое значение 3, то в свойстве объекта останется значение 5, а в локальной переменной
// будет 3. Если же свойство объекта передает в переменную сложный тип данных, то создастся ссылка на значение
// объекта и при изменении значения в локальной переменной, произойдет изменение значения и в свойстве объекта.

// Что произойдет, если мы будем деструктуризировать свойство, у которого в объекте нет значения или вообще нет
// такого свойства ? К примеру свойство author у которого нет значения либо его нет в объекте .В консоли будет
// undefined.В таком случае нам может понадобиться присвоить таким переменным(переданым свойствам), значение по
// умолчанию.Для этого при создании локальной переменной указываем значение через равно: author = 'user'. При
// этом в сам объект свойство и его значение не добавится(т.к.примитив).Если такое свойство есть в объекте и
// имеет значение, то оно перезапишется в лок.переменной.

// Что если мы хотим чтобы название локальной переменной было другим нежели свойство объекта ? К примеру, в
// в объекте свойство "trackCount", а в локальной переменной хотим чтобы называлось "numberOfTracks".
// Для этого добавляем через ":", а именно: trackCount: numberOfTracks. Если для этой переменной необходимо
// задать дефолтное значение, то через "=": trackCount: numberOfTracks = 0,

// const {
//   rating,
//   tracks,
//   name,
//   trackCount: numberOfTracks = 0,
//   author = 'user',
// } = playlist;

// console.log(numberOfTracks);

// Выше мы рассмотрели плоскую(простую) деструктуризацию.Когда в объекте есть простые свойства(т.е.без
// вложений)

/*
 * Глубокая деструктуризация
 */

// Ниже пример объекта с вложенными свойствами:
// const profile = {
//   name: 'Jacques Gluke',
//   tag: 'jgluke',
//   location: 'Ocho Rios, Jamaica',
//   avatar: 'https://s3.amazonaws.com/uifaces/faces/twitter/r_oy/128.jpg',
//   stats: {
//     followers: 5603,
//     views: 4827,
//     likes: 1308,
//   },
// };

// Т.е.чтобы огласить локальные переменные на основе свойств вложенного объектам в объект, мы можем указать
// так: const {followers, views, likes} = stats, но более оптимально будет так:
// stats: { followers, views, likes }. Т.е. по факту у нас деструктуризация в деструктуризации или глубокая
// деструктуризация:

// const {
//   avatar,
//   name,
//   tag,
//   location,
//   stats: { followers, views, likes },
// } = profile;

// console.log(name, tag, location, avatar, followers, views, likes);

// Если у нас есть необходимость переназвать переменную которая создана на основе свойства объекта вложенного в
// объект мы переименовываем по аналогии с плоской деструктуризацией (в т.ч. можем сразу задавать дефолтное
// значение, к примеру "5"):

// const {
//   avatar,
//   name,
//   tag,
//   location,
//   stats: { followers:foloweri = 5, views, likes },
// } = profile;

/*
 * Деструктуризация массивов
 */

// В 99 % случаев деструктуризация используется для объектов, но иногда возникает необходимость деструктуризировать
// и массив

// const rgb = [255, 100, 80];

// const [red, green, blue] = rgb;

// console.log(red, green, blue);

// Если нам необходимо деструктуризировать не все свойства, а только какую то часть, то на месте пропущенного
// свойства мы указываем "," без свойства, к примеру:
// const [red, , blue] = rgb;
// или так, если первый не нужен
// const [, green, blue] = rgb;
// и т.д.

// Теперь на примере реального юзкейса:

// const authors = {
//   kiwi: 4,
//   poly: 7,
//   ajax: 9,
//   mango: 6,
// };

// const rating = Object.values(authors);
// console.log(Math.max(...rating))

// v1:
// const entries = Object.entries(authors);
// for (const entrie of entries) {
//   const name = entry[0];
//   const rating = entry[1];
// }
// console.log(entries);

// v2: Деструктуризируем прям в цикле:
// for (const [name, rating] of entries) {

//   const [name, rating] = entry;

//   console.log(name, rating);
// }
// Пока не понятно, но видимо круто))

/*
 * Операция rest (сбор)
 */
// Операция rest(сбор) это обратное операции spread.Бывает необходимость из одного объекта собрать новый объект,
// без каких-то свойств.

// const profile = {
//   name: 'Jacques Gluke',
//   tag: 'jgluke',
//   location: 'Ocho Rios, Jamaica',
//   avatar: 'https://s3.amazonaws.com/uifaces/faces/twitter/r_oy/128.jpg',
//   stats: {
//     followers: 5603,
//     views: 4827,
//     likes: 1308,
//   },
// };

// К примеру, мы деструктуризируем часть свойств объекта, "name, tag, location,", а все остальные свойства, которые
// не вошли в деструктуризацию, уходят в локальную переменную (к примеру restProps), через операцию rest (т.е. "...")

// const { name, tag, location, ...restProps } = profile;
// В результате мы получаем три локальные переменные "name", "tag", "location" и объект "restProps",
// оригинальный объект при этом не меняется:

// console.log(name, tag, location);
// console.log(restProps);
// console.log(profile);

/*
 * Паттерн «Обьект настроек»
 * - деструктуризация параметра-обьекта в подписи функции
 * - rest при деструктуризации в подписи
 */

// !!! Паттерн «Обьект настроек» на практике используется часто и повсеместно, поэтому важно хорошо понимать !!!

// Очень часто в свои функции мы будем получать не просто набор аргументов, а один объект, такое действие
// называется Паттерн «Обьект настроек». Передавать через функцию множество аргументов обычно не удобно, т.к.
// необходимо помнить последовательность параметров и в каком аргументе что передается. Легко запутаться,
// особенно тем кто юзает код после вас или вы после кого-то.
// Если у нашей функции 4 и более аргументов, то обязательно необходимо применять Паттерн «Обьект настроек».
// 1-3 аргумента ещё как то можно передавать в аргументах, более уже сложнее, т.к. легко запутаться.

// В примере, у нас есть функция showProfileInfo, в которую мы будем передавать переменную "profile"

// const showProfileInfo = function (userProfile) {

//   // Деструктуризируем так:
//   const { name, tag, location, ...restProps } = userProfile;

//   // console.log(name, tag, location, avatar, followers, views, likes);
//   console.log(restProps);
// };

// // либо деструктуризируем сразу в функции:
// const showProfileInfo = function ({
//   name,
//   tag,
//   location,
//   avatar,
//   stats: { followers, views, likes },
// }){
//   console.log(name, tag, location, avatar, followers, views, likes);
// };

const showProfileInfo = function (userProfile) {
  //  Если не все свойства объекта необходимо деструктуризировать, то часть через rest передаем как объект:
  const { name, tag, location, ...restProps } = userProfile;

  // console.log(name, tag, location, avatar, followers, views, likes);
  console.log(restProps);
};

// Такой вариант передачи аргументов гораздо более читабельнее и понятнее в использовании:
const profile = {
  name: 'Jacques Gluke',
  tag: 'jgluke',
  location: 'Ocho Rios, Jamaica',
  avatar: 'https://s3.amazonaws.com/uifaces/faces/twitter/r_oy/128.jpg',
  stats: {
    followers: 5603,
    views: 4827,
    likes: 1308,
  },
};

// т.е. при вызове функции showProfileInfo, в параметре "userProfile", передается целиком объект "profile"
showProfileInfo(profile);
