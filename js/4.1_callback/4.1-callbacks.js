/*
 * Функция обратного вызова (callback)
 * - Функция может принимать другие функции как параметры
 * - Функция которая передаётся другой функции как аргумент называетс
 *   «функцией обратного (отложенного) вызова» (callback-функция)
 * - Функция которая принимает другую функцию как параметр
 *   или возвращает функцию как результат своей работы называется «функцией высшего порядка»
 */


// Функция которая передается как аргумент в другую функцию, называется отложенной функцией или callback функцией.
// Функция, которая принимает другую функцию называется функцией высшего порядка.

// const fnA = function (message, callback) {
//     console.log(message);

//     console.log(callback);
//     callback(100);
// };

// const fnB = function (number) {
//     console.log('Это лог при вызове fnB', number);
// };

// fnA('qweqwe', fnB);

// Опишем суть: создаем функцию fnA которая имеет два параметра(переменные) - message и callback .Где message
// это параметр из самой фунции fnA, а параметр callback это ссылка на функцию fnB описанную ниже.

// По шагам:
// 1. В 21 строке объявляем функцию fnB и указываем её в строке 25 как второй аргумент при вызове функции fnA
// 2. fnB записалась как второй параметр callback при объвлении функции fnA в 14 строке.
// 3. В строке 18 мы вызываем функцию fnB как callback(100);
// 4. Значение 100 из callback(100) на строке 18 приехало в строку 21 для параметра number
// 5. В строке 22 параметр number принял значение 100 и подставилось в текстовое сообщение.

// В данном примере функция fnB - является функцией обратного вызова или callback, а функция fnA - является
// принимающей функцией и выступает функцией высшего порядка.

/*
 * функция doMath(a, b, callback)
 */

// const doMath = function (a, b, callback) {
//     const result = callback(a, b);

//     console.log(result);
// };

// const add = function (x, y) {
//     return x + y;
// }
// const sub = function (x, y) {
//     return x - y;
// }

// doMath(2, 3, add);
// doMath(10, 8, sub);

// По шагам:
// 1. В строке 50 объявили функцию add
// 2. Передали add как аргумент в строку 54
// 3. Из строки 54 функция add записалась в строку 44 в парметр callback для функции doMath
// 4. В строке 45 вызываем этот callback(т.е.функцию прописанную в 50 - 52 строках), где происходит вычисление
// и выводится в результат на 47 строке.
// 5. Параметры а и b сначала объявляются как условие в 54 строке, далее передаются в функцию doMath на 44 строке,
// откуда подставляются в callback на 45 строке. Зачения возвращаются для "а" = "х" из 50 строки, а "b" = y из
// 50 строки.

// В строках 50 и 53 я записал функции с разными вычислениями, а в строке 44 уже вызываю callback с параметром для
// вычисления, которые прописаны в функциях 50 и 53. Параметр передается из строк 57 и 58, и в завиимости от того
// какой аргумент указан add или sub, функция doMath будет возвращать результат с необходимым(указанным) вычислением.

// Выше мы записывали функции в некие переменные, к примеру в нашем случае "add" и "sub".Это делается в тех
// случаях когда мы хотим использовать эти переенные не один раз.Но если нам не нужна функция во внешнем коде,
// мы можем записать её как inline (или одноразовая или встроенная, которая используется только в конкретном
// месте, конкретного кода) функцию:

// doMath(2, 3, function (x, y) {
//     return x + y;
// });

// doMath(10, 8, function (x, y) {
//     return x - y;
// });

/*
 * Отложенный вызов: регистрация событий
 */

// const buttonRef = document.querySelector('.js-button');

// const handleBtnClick = function () {
//     console.log('Клик по кнопке ' + Date.now());
// };

// buttonRef.addEventListener('click', handleBtnClick);

// Вышеописанный код описывает usecase при котором выполняется логирование каждого клика по кнопке где - нибудь
// на web странице.К примеру, на web странице есть форма у которой есть кнопка.Нам необходио подсчитывать
// кол - во нажатий(переходов) на эту кнопку.Для этого мы пишем функцию, которая будет реагировать на событие,
// в нашем случае на каждый клик и логировать в виде сообщения "Клик по кнопке".



/*
 * Отложенный вызов: геолокация
 */

// const onGetPositionSuccess = function (position) {
//     console.log('Это вызов onGetPositionSuccess');
//     console.log(position);
// };

// const onGetPositionError = function (error) {
//     console.log('Это вызов onGetPositionError');
//     console.log(error);
// };

// window.navigator.geolocation.getCurrentPosition(
//     onGetPositionSuccess,
//     onGetPositionError,
// );

// Выше описан ещё один юзкейс при котором выполняется определение геолокации пользователя, разберем по частям:

// const onGetPositionSuccess = function (position) {
//     console.log('Это вызов onGetPositionSuccess');
//     console.log(position);
// }; - это функция, которая отработает в случае если пользователь в браузере примит условия и поволит
// определить себя.В результате выведется сообщение с координатами нахождения пользователя.Сама функция
// не определяет координаты(их определяет встроенные в браузер метод - window.navigator.geolocation.getCurrentPosition)
// она лищ сообщает об успешном выполнении фнкции определения геолокации.

// const onGetPositionError = function (error) {
//     console.log('Это вызов onGetPositionError');
//     console.log(error);
// }; - это функция выполняется в случае если пользователь отклонил возможность определить его геолокацию.
// Просто сообщает об ошибке.

// window.navigator.geolocation.getCurrentPosition(
//     onGetPositionSuccess,
//     onGetPositionError,
// ); - а это уже полный код который определяет геолокацию (благодаря встроенному методу) и если успешно то
// выводит результат с помощью колбек функции onGetPositionSuccess, если ошибка то выведет результат из другой
// колбек функции onGetPositionError. Всё!


/*
 * Отложенный вызов: интервалы
 */

// const callback = function () {
//     console.log('Через 2 секунды внутри колбека в таймауте');
// };

// console.log('В коде перед таймаутом');
// setTimeout(callback, 2000);
// console.log('В коде после таймаута');

// Суть этого примера, продемонстрировать запуск колбэк функции с отложенным зпуском.SetTimeout вызывает
// функцию callback и через 2 секунды выводит в консоль сообщение 'Через 2 секунды внутри колбека в таймауте'


/*
 * Отложенный вызов: http-запрос
 * - API URL: https://pokeapi.co/api/v2/pokemon
 */

// const onRequestSuccess = function (response) {
//     console.log(
//         'Вызов функции onRequestSuccess после успешного ответа бекенда',
//     );
//     console.log(response);
// };

// fetch('https://pokeapi.co/api/v2/pokemon')
//     .then(res => res.json())
//     .then(onRequestSuccess);

// Суть:
// 1. Объявили функцию onRequestSuccess
// 2. Указали в вызове метода стр 179 как колбэк
// 3. Когда отработала функция, вернули результат через консоль лог строки 171-174



/*
 * Фильтр
 */

// 1. Опишем функцию которая переберает исходный массив и возвращает новый массив, который соответствует 
// условию прописанному в колбэк функции (параметр test), в строке 217-2019:

const filter = function (array, test) {
    const filteredArray = [];

    for (const el of array) {
        console.log(el);
        const passed = test(el);

        if (passed) {
            filteredArray.push(el);
        }
    }

    return filteredArray;
};

// Опишем логику проверки:
// 1. надо передать функцию
// 2. функция получает элемент массива
// 3. если элемент массива удовлетворяет условию то функция вернет true
// 3. если элемент массива НЕ удовлетворяет условию то функция вернет false

// Опишем функцию(колбек) с условием 1. Её суть такая, получает элемент из массива и проверяет его на заданное
// условие, если соответствует условию то true, если нет то false:
const callback1 = function (value) {
    return value >= 3; // т.е. должен возвращаться новый массив с элементами которые больше "3" 
};

const r1 = filter([1, 2, 3, 4, 5], callback1);
console.log(r1);
// сокращенно можно записать так:
// console.log(filter([1, 2, 3, 4, 5], callback1));

// Опишем функцию(колбек) с условием 2:
const callback2 = function (value) {
    return value <= 4;
};

// const r2 = filter([1, 2, 3, 4, 5, 6, 7, 8], callback2);
// console.log(r2);

// Колбэк функцию ещё можно записать так:
// const r2 = filter([1, 2, 3, 4, 5, 6, 7, 8], function (value) {
//     return value <= 4;
// });
// console.log(r2);

// или совсем сокращенно:
console.log(filter([1, 2, 3, 4, 5], function(value) {
    return value <= 4;
}));

// Распишем алгоритм выполнения:

// 1. В строках 217-219 объявляем колбэк функцию с условием
// 2. Передаем колбэк функцию (шаг1) в строку 221 как аргумент callback
// 3. аргумент callback из строки 221 подставляется в функцию Фильтр в строку 194 на место параметра test
// 4. Внутри функции Фильтр в строка 199 мы каждый раз вызываем параметр test (т.е. колбэк функцию
// описанную в шаге 1), при переборе массива

// На каждой итерации цикла в строках 197 - 199, в строку 199 в переменную const passed = test(el) на место
// (el) подставляется по порядку каждый элементмассива.Первым подставиться значение "1", потом "2" и так далее
// до "8"(наш массив).Далее эта "1"(или el) записывется в параметр(value), колбэк функции по строке 217.
// Этот(value) проверяется в строке 218 на соответствие условию.В зависимости от результата проверки в строку
// 198 запишется true или false.Если эллемент прошел условие и возвращает true, то значение записывается (пушится)
// в новый массив(см.стр.202).Строка 206 выведет в консоль итоговый массив, наполненный элементами, которые
// соответствуют условию колбэк функции описанной в строке 217-219


// Описанная выше функция(стр. 192 - 208) является масштабируемым решением т.к. в неё можно передавать любые 
// массивы(параметр array) и колбэки(параметр test), с различными условиями. 
// Ниже рассмотрим пример с другим массивом, где используется выше описанная масштабируемая функция: 


// ----------------------------------------------------------------------------------------------------

// ЕЩЁ РАЗ РАЗБЕРЕМ РЕШЕНИЕ ПО_ШАГОВО:

// 1. Используем масштабируемую функцию, куда подставляем произвольный массив и колбэк с любым условием:
// const filter = function (array, test) {
//     const filteredArray = [];

//     for (const el of array) {
//         console.log(el);
//         const passed = test(el);

//         if (passed) {
//             filteredArray.push(el);
//         }
//     }

//     return filteredArray;
// };

// // 2. У нас как условие есть массив данных:
// const fruits = [
//     { name: 'apples', quantity: 200, isFresh: true },
//     { name: 'grapes', quantity: 150, isFresh: false },
//     { name: 'bananas', quantity: 100, isFresh: true },
// ];

// // 3. Описываем колбэк функцию, которая имеет условие: 
// const getFruitsWithQuantity = function (fruit) {
//     return fruit.quantity >= 120;
// };


// // 4. Вызываем функцию с параметрами:
// const r3 = filter(fruits, getFruitsWithQuantity);
// console.log(r3);

Пошаговый алгоритм решения детально описан в строках 