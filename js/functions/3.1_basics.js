// Темы:
// 1. Функции:
//     - Функциональные выражения
//     - Аргументы и параметры
//     - Возврат значения

// 2. Стек вызовов
// 3. Stack trace и поиск ошибок

// 1. Функции:
//     - Функциональные выражения
//     - Аргументы и параметры
//     - Возврат значения

// Функция должна отвечать на вопрос: что делаю?

// const add = function (x, y) {console.log(x); console.log(y);} - функция как и метод, состоит () - где 
// указывается  "параметры" и { } - тело функции, где указываются аргументы (описывается увсловие).

// const add = function (x, y) {
// console.log(x);
// console.log(y);
//  console.log('Выполняет функию add');
// };

// !!!Внимание!!! Код выше, только лишь объявляет функцию, присваивая её будущее значение переменной.Такой
// код сам по себе не запускает выполнение функции.Она может быть в последствии запущенна из любого другого
// места ниже по кода.Для того чтобы вызвать функцию и её запустить.Необходимо будет указать имя переменной
// в которой лежит эта функция, вот так: add ()

// const add = function (x, y) {
//   console.log(x);
//   console.log(y);
// Укажем, что именно должно выполняться через функцию
//   const result = x + y;
//   console.log('х + у = ', result);
//   console.log('Выполняет функию add');

// В конце функции укажем return, который возвращает одно значение(это может быть что угодно: массив,
// число, строка и т.д.)
//     return result;

// };

// add(2, 3);
// add(20, 30);
// add(40, 350);
// Получается что я 3 раза запустил (вызвал) функцию add, после каждого вызова в коносль выведется значение
// функции - её аргументы.А именно для параметра "х" при вызове функции присвоен аргумент 2, а для "у" - 3.

// Перепишем:
// const add = function (x, y) {
//     console.log(x);
//     console.log(y);
//   console.log('Выполняет функию add');

//   return x + y;

// return - ретёрн выполняет(отвечает за) возврат результат из функции, в то место откуда вызвали
// эту функцию, как правило в переменную за пределами функции. Как только код выполняет return, выполнение
// функции прерывается; Если в теле функции до return встречается console.log() либо другой код, то он
//   будет выполнен и выведен на экран, если после return, то нет.

//   const r1 = add(10, 15);
//   console.log('r1 = где x = 10 + y = 15: ', r1);

// Последовательность такая:
// 1. Объявили функцию const add = function (x, y)
// 2. Записали через ретёрн, что должно произойти: return x + y;
// 3. За рамками функции объявили переменную: const r1
// 4. Через переменную const r1 вызвали функцию add()
// 5. Вызванная функция add(), в своем теле через return выполняет вычисление: return x + y;
// 6. Результат вычисления в return x + y; возвращается в переменную, которая вызвала данную функцию const r1
// 7. Полученное значение выводим в консоль: console.log(r1);

// Хорошая практика, это когда функция не использует что - то вне себя, все что она использует это аргументы,
// которые мы в неё передаём.В нашем случае вне функции мы указываем переменные r1 = add(10, 15);
// а функция эти аргументы принимает и отрабатывает.
// Не обязательно прям выводить переменную const r1 = add(10, 15); и потом её значение выводить, через
// консоль. Можно сразу записать вот так:

//   console.log('Результат функции: ', add(10, 15));

// Ну а вообще суть такая: объявили функцию и указали в теле функции, что должно делаться с помощью данной
// функции, ну а далее уже за рамками данной функции можем создавать неограниченное кол - во переменных с
// использованием данной функции, при этом аргументы для каждой переменной могут быть разные.
// Простыми словами, к примеру написали формулу расчета фин.показателя, и при необходимости далее,
// подставляем эту функцию(формулу), для рассчета необходимого нам показателя(переменной). К примеру для
// разных юридических лиц значение фин.показателя будет разным, но формула (функция) будет одна:
//   const workingCapital = function (x, y, w, t) {
//     console.log('Выполняет функию расчёта показателя Net Working Capital:');
//     return x + y + w - t;
//   };
//   const ratio1 = workingCapital(150, 200, 80, 175);
//   console.log('Значение NWC для Компании 1: ', ratio1);

//   const ratio2 = workingCapital(350, 10, 180, 475);
//   console.log('Значение NWC для Компании 2: ', ratio2);

//   const ratio3 = workingCapital(150, 50, 10, 275);
//   console.log('Значение NWC для Компании 3: ', ratio3);
// };

// return используется в циклах и может указыватьсь в if по условию. Т.е. если условие выполняется/не
// выполняется, то return и выход из функции.

// const fn = function (value) {
//   if (value < 50) {
//     return 'Меньше чем 50';
//   }
//   return 'Больше чем 50';
// };
// console.log('Результат функции1: ', fn(10));
// console.log('Результат функции2: ', fn(1000));

// 2. Стек вызовов
// !!! Это важная концепция и её обязательно надо понимать !!!
// Стек вызовов - это такой тип, такая конструкция, к примеру как стопка книг, в которую можно положить
// доп.книгу только либо наверх, либо в самый низ стопки. В середину положить ничего нельзя.

// const fnA = function () {
//   console.log('Выполняется функция А');
// };
// const fnB = function () {
//   console.log('Выполняется функция B');
// };
// const fnC = function () {
//   console.log('Выполняется функция C');
// };

// fnA();
// fnB();
// fnC();

// В данном случае на стек будет ставиться поэтапно все функции по-порядку:
// 1. console.log('Выполняется функция А'); >> 2. fnA(); >> 3. console.log('Выполняется функция В');
// >> 4. fnВ(); >> 5. console.log('Выполняется функция С'); >> 6. fnС();

// Другой вариант, более сложный, а именно все эти функции вложены друг друга как в мсатрёшку:

// const fnA = function () {
//   console.log('Выполняется функция А');
//   fnB();
// };
// const fnB = function () {
//   console.log('Выполняется функция B');
//   fnC();
// };
// const fnC = function () {
//   console.log('Выполняется функция C');
// };

// fnA();

// В данном случае, когда мы вызовем fnA, в стеке будет выполняться такая последовательность:
// 1. fnA() - ставится на стек и находится там пока не отработают все логи и fnВ() и fnС() >>
// 2. console.log('Выполняется функция А') - отрабатывает лог и сразу снимается со стека >>
// 3. fnВ(); ставится на стек и находится там пока не отработают лог для В и С и fnС() >>
// 4. console.log('Выполняется функция В'); - отрабатывает лог и сразу снимается со стека >>>>
// 5. fnС(); >> ставится на стек и находится там пока не отработают лог для С >>
// 6. console.log('Выполняется функция С'); - отрабатывает лог и сразу снимается со стека >>


// 3. Stack trace и поиск ошибок
// Stack trace - находится в консоли веббраузера, там же и где область вывода результата нашего кода,
// просто когда возникает ошибка, появляется информация об ошибке в коде, нажав на которую можно
// провалиться глубже и увидеть более детально где именно эта ошибка возникла.К примеру если переменная
// не объявлена, но мы её указываем в коде, в консоль выдаст ошибку.

// Посмотрим на примере:
const fnA = function () {
  console.log('Выполняется функция А');
  fnB();
};
const fnB = function () {
  console.log('Выполняется функция B');
  fnC();
};
const fnC = function () {
    console.log('Выполняется функция C');
    console.log(value);
};

fnA();

// В консоли мы увидим сообщение об ошибке, где указано, что переменная value is not defined, если нажмем
// на строку at fnC(3.1_basics.js: 181: 17), то нас перенесёт на вкладку source и строку где была указана,
// эта переменная    
// Uncaught ReferenceError: value is not defined
//     at fnC (3.1_basics.js:181:17)
//     at fnB (3.1_basics.js:177:3)
//     at fnA (3.1_basics.js:173:3)
//     at 3.1_basics.js:184:1
// fnC @ 3.1_basics.js:181
// fnB @ 3.1_basics.js:177
// fnA @ 3.1_basics.js:173
// (anonymous) @ 3.1_basics.js:184