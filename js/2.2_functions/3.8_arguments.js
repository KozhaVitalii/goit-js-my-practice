// Псевдомассив arguments и Array.from и ....

// Иногда нам необходимо написать функцию, для которой мы заранее не знаем сколько будет параметров и какое
// кол - во аргументов будет в них.Для таких целей в функциях есть встроенная переменная, которая
// называется "arguments". Её не надо дополнительно объявлять, она есть как зарезервированное ключевое слово.
// arguments - это псевдомассив, который имеет ограниченный набор методов. Можно вывести его в коносль, чтобы
// посмотреть доступные методы. Аrguments можно перебрать через for, но такие методы как pop, push и др. для
// данной функции недоступны. Для того чтобы методы стали доступны, понадобится взять псевдомассив Аrguments
// и преобразовать в настоящий массив. Как это сделать? Для этого необходимо:

// Первый олдскульный метод:
// const fn = function () {
//   console.log(arguments); // псевдомассив до преобразования в реальный массив
// }
// const args = Array.from(arguments) // преобразование псевдомассива в реальный массив
//   console.log(args); // псевдомассив после преобразования. Єто уже полноценный массив со всеми доступными методами

// fn(1, 2, 3, 4, 5, 6, 7);

// Второй метод, с более современным синтаксисом
// В параметр "(...args)" собираются абсолютно все массивы которые были переданы в функцию после чего в функции
// лежат не псевдомассивы а полноценные массивы. Т.е. олдскульный метод преобразования "Array.from(arguments)"
// мы заменяем на "(...args)"

// const fn = function (...args) {
//     console.log(args);
// }
// Аргументы массивов из всех 3-х функций запишуться в один массив (...args):
// fn(1, 2, 3);
// fn(1, 2, 3, 4, 5, 6);
// fn(1, 2, 3, 4, 5, 6, 7);

// А что если в наших функциях, аргументы будут иметь разный тип данных? К примеру:
// const fn = function (a, b, c, ...args) {
//     console.log(`${a} ${b} ${c}`);
//     console.log(args);
// }
// fn('hello', 1, 2, 3);
// fn('aloha', 1, 2, 3, 4, 5, 6);
// fn('hi', 1, 2, 3, 4, 5, 6, 7);

// В нашем примере для функции function (a, b, c, ...args) в параметры a, b, c, ...args запишуться следующие
// аргументы:

// fn(В параметр "а" запишется аргумент 'hello', в параметр "b" запишется аргумент 1 в параметр "с" аргумент 2,
// в параметр rest (...args) передаются все остальные аргументы, т.е. только - 3);
// fn(В параметр "а" запишется аргумент 'aloha', в параметр "b" запишется аргумент 1, в параметр "с" аргумент 2,
// в параметр rest (...args) передаются все остальные аргументы, т.е. 3, 4, 5, 6);
// fn(В параметр "а" запишется аргумент - 'hi', в параметр "b" запишется аргумент - 1, в параметр "с" аргумент 2,
// в параметр rest (...args) передаются все остальные аргументы, т.е. 3, 4, 5, 6, 7);

// По факту, мы расписываем, какие аргументы мы хотим передавать отдельно, а какие передавать через массив. В нашем
// примере аргументы для параметров а, b, c(т.е.первые три аргумента при вызове функции передаются отдельно, а все
// остальные передаются как массив, через rest (т.е. "...args")
// Внимание, параметр "...args" - это операция "rest" и он ставится всегда в самом конце

// Напиши функцию add для сложения произвольного кол - ва аргументов(чисел)
// - Операция...(rest)

// const add = function (...args) {
//   console.log(args);
//   let total = 0;

//   for (const arg of args) {
//     total += arg;
//   }
//   return total;
// };

// console.log(add(1, 2, 3));
// console.log(add(1, 2, 3, 4, 5, 6));
// В итоге мы написали функцию, которая объединяет все аргументы в один массив, далее суммирует
// их и выводит в консоль


// Напиши функцию filterNumbers(array[, number1, ....]), которая:
// - первым аргументом принимает массив чисел
// - после первого аргумента может быть произвольное кол-во других аргументов которые будут числами
// - функция должна вернуть новый массив, в котором будут только те аргументы, начиная со второго,
// для которых есть аналог оригинальном массиве

// Другими словами задачка такая, при вызове функции (в которой из аргументов есть 1. в начале массив, 
// 2. произвольные числа в виде аргументов), взять произвольные числа и сравнить с массивом. Те 
// произвольные числа, которые совпадают с массивом (т.е. такие же числа есть в массиве), записать в новый
// массив  

const filterNumbers = function (array, ...args) { 
    // console.log(array);
    // console.log(args);
    const uniqueNumbers = [];

    for (const number of array) {
        if (args.includes(number)) {
            uniqueNumbers.push(number);
            // console.log(`${number} совпадает в массивах!`);
        }
        }
        return uniqueNumbers;
};

console.log(filterNumbers([1, 2, 3, 4, 5], 10, 15, 2, 3, 8)); // [2, 3]
console.log(filterNumbers([10, 15, 25, 30], 23, 30, 18, 15)); // [30, 15]
console.log(filterNumbers([100, 200, 300, 400, 500], 7, 12, 200, 64)); // [200]

